<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 博弈论 </font> </center>

### 巴什博奕：
只有一堆,共`n`个物品，两个人轮流从中取物，规定每次最少取一个，最多取`m`个，最后取光者为胜。（或者规定为如果无法操作者失败）
**结论：**
如果$n \% (m + 1) == 0$ 则后手必胜，否则，先手必胜

**理解**
如果剩下的石子数$n^{'} \% (m + 1) == 0$, 那么接下来拿的人必败。
因为如果它拿`x`个,那么另一个人可以拿`y`个，`x + y = m + 1`, 因此保证`y`肯定大于`1`小于`m`，是合法的。
因此，如果$n^{'} \% (m + 1) == 1$ 先手可以拿`1`个，留给后手必败局面；
如果$n^{'} \% (m + 1) == 2$ 先手可以拿`2`个，留给后手必败局面；
如果$n^{'} \% (m + 1) == m$ 先手可以拿`m`个，留给后手必败局面；
但如果如果$n^{'} \% (m + 1) == 0$ 先手直接失败。


### 威佐夫博弈：
有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。（或者规定为如果无法操作者失败）

**结论:**
若两堆物品的初始值为`(x，y)`，且`x<y`，则另`z=y-x`；
记`w=(int) (sqrt(5)+1)/2)*z)`；
若`w=x`，则先手必败，否则先手必胜。


### 尼姆博弈：
有任意堆物品，每堆物品的个数是任意的，双方轮流从中取物品，每一次只能从一堆物品中取部分或全部物品，最少取一件，取到最后一件物品的人获胜。
**结论：**
把每堆物品数全部异或起来，如果得到的值为`0`，那么先手必败，否则先手必胜。
**理解：**
当剩余的各堆物品全部异或后为`0`,那么接下来拿的人必败。
不论先拿的人怎么拿，之后的人只要维持剩余的各堆物品全部异或后为`0`，就可保持胜利。

<img src="../Fig/尼姆博弈.png">


### 斐波那契博弈：
有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。

**结论：**
`n`如果是斐波那契数(`n`为物品总数)，先手必败。


### 公平组合游戏`ICG`
若一个游戏满足：

(1)由两名玩家交替行动；
(2)在游戏进程的任意时刻，可以执行的合法**操作与**轮到哪名**玩家无关**；
(3)不能行动的玩家判负；
则称该游戏为一个公平组合游戏。

尼姆博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。

### 有向图游戏
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。

**任何一个公平组合游戏都可以转化为有向图游戏**。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。

#### Mex运算
设`S`表示一个非负整数集合。定义`mex(S)`为求出不属于集合`S`的最小非负整数的运算，即：
`mex(S) = min{x}`, `x`属于自然数，且`x`不属于`S`

#### SG函数
在有向图游戏中，对于每个节点`x`，设从`x`出发共有`k`条有向边，分别到达节点`y1, y2, …, yk`, 定义`SG(x)`为`x`的后继节点`y1, y2, …, yk `的`SG`函数值构成的集合再执行`mex(S)`运算的结果，即：
`SG(x)` = `mex({SG(y1), SG(y2), …, SG(yk)})`
特别地，整个有向图游戏`G`的`SG`函数值被定义为有向图游戏起点`s`的`SG`函数值，即`SG(G)` = `SG(s)`。`SG`(终点) `= 0`


#### 定理
有向图游戏的某个**局面必胜**，当且仅当该局面对应节点的`SG`函数值**大于`0`。**
有向图游戏的某个**局面必败**，当且仅当该局面对应节点的`SG`函数值**等于`0`。**


#### 有向图游戏的和 [多个图]
设`G1, G2, …, Gm`是`m`个有向图游戏。定义有向图游戏`G`，它的行动规则是**任选某个有向图**游戏`Gi`，并在`Gi`上行动一步。`G`被称为有向图游戏`G1, G2, …, Gm`的和。
有向图游戏的和的`SG`函数值等于它包含的各个子游戏`SG`函数值的异或和，即：`SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)`[证明思路类似尼姆博弈]


### AcWing 893. 集合-Nim游戏
```c++
2      //k个数
2 5    // 每次的操作只能是这k个数中选一个
3       // 3堆石子
2 4 7   // 每堆石子的数量

ans = "先手必胜"
```
现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含在k个数中选一个，最后无法进行操作的人视为失败。

#### 思路： SG函数

每堆石子建一个有向图，求取每堆石子的$SG(G_i)$
然后转化为尼姆博弈，所有图的`SG`函数等于`SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)`
如果异或值等于`0`，先手必败，否则先手必胜

简单证明：`SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)`
假设`SG1 = 6, SG2 = 2, SG3 = 3`
按照`SG`函数的定义：`SG(x)` = `mex({SG(y1), SG(y2), …, SG(yk)})`
`SG1 = 6`,说明不在其出边操作集合中的最小的数为`6`, 也就是说其`SG1`的出边集合必然包括`[0, 1, 2, 3, 4, 5, ...)`, 这里面的数就是可选的操作。
将不同堆的石子的`SG`函数看成石子数，上述问题就转化为了尼姆博弈问题。
`SG1 ^ SG2 ^ SG3 = 110 ^ 010 ^ 011 = 7 != 0`
因此先手可以通过操作将局面变为异或值全为`0`的局面
具体为：异或值`x = 7`对应二进制中`1`的最高位对应的数为`6`，因此这一堆石子选择操作`6 - x ^ 6 = 5`（上面已经证明可以取到操作5）,那么这一堆剩下的石子为`6 - 5 = 1`,最后异或的结果为`0`。 

```c++
# include<bits/stdc++.h>
using namespace std;
int k, n;
int S[110], f[10010]; //S存储的是可供选择的操作集合,f存储的是所有可能出现过的情况的sg值

// SG函数本质就是一个记忆化搜索的DFS
int SG(int x) {
    if(f[x] != -1) return f[x];  // 之前有结果
    
    unordered_set<int>hx;
    for(int i = 0; i < k; i++) { // 一共k种可行操作
        int num = S[i];
        if(x >= num) hx.insert(SG(x - num));
    }
    // mex运算,找不在hx集合中最小的自然数
    for(int i = 0; ; i++) {
        if(hx.count(i) == 0) {
            f[x] = i;
            break;
        }
    }
    return f[x];
}
int main(){
    memset(f, -1, sizeof(f));
    cin >> k;
    for(int i = 0; i < k; i++) cin >> S[i];
    cin >> n;
    int res = 0;
    for(int i = 0; i < n; i++) { // 每堆石子
        int x;
        cin >> x;
        res ^= SG(x);  // 异或每一堆石子的SG函数
    }
    if(res == 0) cout << "No" << endl;
    else cout << "Yes" << endl;
    return 0;
}

```
---

### acwing 892. 台阶-Nim游戏 [尼姆博弈变种]
有一个`n`级台阶的楼梯，每级台阶上都有若干个石子.两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。

**结论：**
如果先手时奇数台阶上的值的异或值为0，则先手必败，反之必胜

**证明**
先手时，如果奇数台阶异或非0，根据经典`Nim`游戏，先手总有一种方式使奇数台阶异或为0，于是先手留了奇数台阶异或为0的状态给后手
于是轮到后手：
①当后手移动偶数台阶上的石子时，先手只需将对手移动的石子继续移到下一个台阶，这样奇数台阶的石子相当于没变，于是留给后手的又是奇数台阶异或为0的状态
②当后手移动奇数台阶上的石子时，留给先手的奇数台阶异或非0，根据经典Nim游戏，先手总能找出一种方案使奇数台阶异或为0

因为偶数台阶上的石子要想移动到地面，必然需要经过偶数次移动，又因为奇数台阶全0的情况是留给后手的，因此先手总是可以将石子移动到地面，当将最后一个（堆）石子移动到地面时，后手无法操作，即后手失败。

---

### acwing 894. 拆分-Nim游戏[集合-NiM游戏变种]
`n`堆石子，两位玩家轮流操作，每次操作可以**取走其中的一堆石子，然后放入两堆**规模更小的石子（新堆规模可以为`0`，且两个新堆的石子总数可以大于取走的那堆石子数），最后无法进行操作的人视为失败。

```c++
# include<bits/stdc++.h>
using namespace std;
int n;
int f[10010]; //f存储的是所有可能出现过的情况的sg值

// SG函数本质就是一个记忆化搜索的DFS
int SG(int x) {
    if(f[x] != -1) return f[x];  // 之前有结果
    
    unordered_set<int>hx;
    for(int i = 0; i < x; i++) // 没堆新石子的取值范围为[0, x - 1]
        for(int j = 0; j <= i; j++)  // 为了避免重复，规定j < i
            hx.insert(SG(i) ^ SG(j)); // 不同点

    // mex运算,找不在hx集合中最小的自然数
    for(int i = 0; ; i++) {
        if(hx.count(i) == 0) {
            f[x] = i;
            break;
        }
    }
    return f[x];
}
int main(){
    memset(f, -1, sizeof(f));
    cin >> n;
    int res = 0;
    for(int i = 0; i < n; i++) { // 每堆石子
        int x;
        cin >> x;
        res ^= SG(x);  // 异或每一堆石子的SG函数
    }
    if(res == 0) cout << "No" << endl;
    else cout << "Yes" << endl;
    return 0;
}
```
---