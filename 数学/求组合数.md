<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 组合数 </font> </center>

### 常规方法：
```c++
long long cal(int n, int m) { // C_n^m
    long long res = 1;
    for(int i = n - m + 1, j = 1; j <= m; i++, j++) {
        res = res * i / j;
    }
    return res;
}
```
这样计算为啥能保证每次相乘都是整数呢？
因为这样算的话：第一次结果等于$C_{n - m + 1}^{1}$,后面依次是：$C_{n-m+2}^{2}$, $C_{n -m + 3}^{3} \dots$每次都是组合数，而组合数为整数。

---

### 组合数1：
求$C_a^b \ mod (1e9 + 7)$, 一共`n`组数：

```c++
n <= 10000
a, b <= 2000
```
如果用上述常规方法，时间复杂度为`O(na)`

#### 递推法求组合数 
$C_a^b = C_{a - 1}^b + C_{a - 1}^{b - 1}$
分析：简单的第`a`个数选或不选

```c++
for(int i = 0; i < N; i++) {
    for(int j = 0; j <= i; j++) {
        if(j == 0) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
    }
}
```
**时间复杂度$O(a^2)$**

---

### 组合数2：
求$C_a^b \ mod (1e9 + 7)$, 一共`n`组数：

```c++
n <= 10000
a, b <= 100000
```

本质就是利用组合数公式：
$C_a^b = \frac{a!}{b!(a - b )!}$

因为 $\frac{a}{b} \% p \ != \  \frac{a \% p} {b \% p}$
因此要转化为逆元来求
即 $\frac{a}{b} \% p \ == a \times b^{-1} \% p$

首先预处理出所有阶乘取模的余数`fact[N]`，以及所有阶乘取模的逆元`infact[N]`,如果取模的数是质数，可以用费马小定理求逆元.
即`b^{-1}= qmi(b, m -2, m) m = 1e9+ 7`

```c++
# include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
const int N = 1e5 + 10;
using ll = long long;
int fact[N], infact[N];
int qmi(int a, int b, int p) {
    ll res = 1 % p;
    for(; b ; b >>= 1) {
        if(b & 1) res = (ll) res * a % p;
        a = (ll)a * a % p;
    }
    return res;
}
void init() {
    fact[0] = infact[0] = 1;
    for(int i = 1; i < N; i ++) {
        fact[i] = (ll) fact[i - 1] * i % mod;
        infact[i] = (ll) infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
}
int main(){
    init();
    int m;
    cin >> m;
    while(m --) {
        int a, b;
        cin >> a >> b;
        cout << (ll) fact[a] * infact[b] % mod * infact[a - b] % mod << endl;;
    }
    return 0;
}
```