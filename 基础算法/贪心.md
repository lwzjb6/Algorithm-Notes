<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 贪心 </font> </center>

### 134. 加油站
在一条环路上有`n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升, 开往下一站需要消耗`cost[i]`。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，题目保证是唯一的
`gas = [1,2,3,4,5], cost = [3,4,5,1,2], ans = 3`

#### 贪心思路1：
`gap[i] - cost[i]`表示在每个加油站的剩余油量
如果从`x-y`的累计剩余油量小于0, 即不可能到达y之后的点
那么从`x-y`之间的任何一点出发均不可能到达y之后的点：
简单理解：`x-z-y`如果从x出发到达z在油量有剩余的情况下都不可能到达y之后的点，那么直接从z出发，剩余油量为0，就更不可能到达了。
因此就不必重新考虑`x-y`之间的点作为起点的情况。

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int cap = 0;
        int start = 0;
        int total = 0;
        for (int i = 0; i < n; i++) {
            cap += gas[i] - cost[i];
            total += gas[i] - cost[i];
            if (cap < 0) { // 当前油箱油量小于0
                cap = 0;
                start = i + 1; // 假设起点应该是当前节点的下一个
            }
        }
        return (total < 0) ? -1 : start;
    }
};
```

#### 贪心思路2：[更好理解]
亏空最严重的一个点必须放在最后一步走，等着前面剩余的救助
因此亏空最严重的点的下一个点就是起点
```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int cap = 0;
        int mini = 1e9, mini_pos = 0; // 亏空最严重的点
        for (int i = 0; i < n; i++){
            cap += gas[i] - cost[i];
            if (cap < mini) {
                mini = cap;
                mini_pos = i;
            }
        }
        return cap < 0 ? -1 : (mini_pos + 1) % n;
    }
};
```
---

### 406. 根据身高重建队列
每个 `people[i] = [hi, ki]` 表示第 `i`个人的身高为 `hi` ，前面正好有 `ki` 个身高大于或等于 `hi` 的人。
`people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]` 
`ans = [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]`

#### 贪心思路1：
```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        int n = people.size();
        // 按身高从小到大排序
        sort(people.begin(), people.end(), [](vector<int>a, vector<int>b){
            if (a[0] != b[0]) return a[0] < b[0];
            else return a[1] > b[1];
        });
        vector<vector<int>>ans(n);
        // 对于每个person，前面预留出person[1]个空位置用于之后放置更大的数
        for (auto person : people) {
            int path = person[1] + 1;
            for (int i = 0; i < n; i++){
                if (ans[i].empty()) path--;
                if (!path) {
                    ans[i] = person;
                    break;
                }
            }
        }
        return ans;
    }
};
```

#### 贪心思路2：
```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        // 按身高从大到小排序
        sort(people.begin(), people.end(), [](vector<int>a, vector<int>b){
            if (a[0] != b[0]) return a[0] > b[0];
            else return a[1] < b[1];
        });
        vector<vector<int>>ans;
        for (auto person : people) ans.insert(ans.begin() + person[1], person);
        return ans;  
    }
};
```

---
### 738. 单调递增的数字
给定一个整数 `n` ，返回 小于或等于 `n` 的最大数字，且数字呈单调递增。
`n = 332, ans = 299`

#### 贪心策略：
从左往右遍历各位数字，找到第一个开始下降的位置`i`，将`a[i]`减1，然后将`a[i+1 ...]`各位数字全部置为9即可

```c++
class Solution {
public:
    int check(vector<int> & a) {
        for (int i = 0; i < a.size() - 1; i++) {
            if (i + 1 >= a.size()) break;
            if (a[i] > a[i + 1]) return i;
        }
        return -1;
    }
    int monotoneIncreasingDigits(int n) {
        vector<int>a;
        while (n) {
            a.push_back(n % 10);
            n /= 10;
        }
        reverse(a.begin(), a.end());
        int pos;
        while ((pos = check(a)) != -1) {
            a[pos]--;
            for(int i = pos + 1; i < a.size(); i++) a[i] = 9;
        }
        int ans = 0;
        for (auto x : a) {
            ans *= 10;
            ans += x;
        }
        return ans;
    }
};
```

上述实现方式主要麻烦在于将数字转为数组以及转回去，更为简洁的实现方式：

```c++
class Solution {
public:
    int check(string & a) {
        for (int i = 0; i < a.size() - 1; i++) {
            if (i + 1 >= a.size()) break;
            if (a[i] > a[i + 1]) return i;
        }
        return -1;
    }
    int monotoneIncreasingDigits(int n) {
        string a = to_string(n);
        int pos;
        while ((pos = check(a)) != -1) {
            a[pos]--;
            for(int i = pos + 1; i < a.size(); i++) a[i] = '9';
        }
        return stoi(a);
    }
};
```
---

### 968. 监控二叉树
给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。

#### 贪心思路：
从底向上递归，保证每个节点都被覆盖
在递归的时候用 `1,2,3`表示3种状态
```c++
0：该节点无覆盖
1：本节点有摄像头
2：本节点有覆盖
```
因为涉及到左右子节点，因此总的情况数为9
```c++
class Solution {
public:
    int ans = 0;
    int dfs(TreeNode* root) {
        if (!root) return 2;
        int l = dfs(root->left);
        int r = dfs(root->right);
        // 包含情况[1](l=0,r=0),[2](l=0,r=1), [3](l=0,r=2),[4](l=1,r=0),[5](l=2,r=0)
        // 只要左右子节点有一个没有被覆盖，当前节点就必须加一个监控
        if (l == 0 || r == 0) {
            ans ++; // 往当前节点加一个监控
            return 1; // 有监控的标记
        }
        //包含情况[6](l=1,r=1),[7](l=1,r=2), [8](l=2,r=1)
        // 左右节点有一个有摄像头，当前节点就能覆盖
        else if (l == 1 || r == 1) return 2;
         //包含情况[9](l=2,r=2) 左右节点都覆盖，本节点不能覆盖
        else return 0;
    }
    int minCameraCover(TreeNode* root) {
        if(dfs(root) == 0) ans++; //根节点无覆盖
        return ans;
    }
};
```
---