<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 额外有价值的题目 </font> </center>

### 189. 轮转数组
将数组中的元素向右轮转 `k` 个位置
`nums = [1,2,3,4,5,6,7], k = 3`
`ans =  [5,6,7,1,2,3,4] `

空间复杂度为$O(1)$的做法：
数组元素向右循环移动`k`位,等价于：
先将数组翻转，然后再翻转前k个元素，再翻转后面的元素

```c++
class Solution {
public:
    // stl中的reverse涉及复制操作，因此自己写一个revserse
    void rev(vector<int>& a, int l, int r) {
        while(l < r) {
            swap(a[l], a[r]);
            l++;
            r--;
        }
    }
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        rev(nums, 0, nums.size() - 1);
        rev(nums, 0, k - 1);
        rev(nums, k, nums.size() - 1);
    }
};
```
---

### 剑指 Offer 03. 数组中重复的数字
在一个长度为 `n` 的数组 `nums` 里的**所有数字都在 `0～n-1` 的范围内**。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

#### 哈希表：
时间复杂度$O(n)$, 空间复杂度$O(n)$

#### 原位置换
找到每个数对应的坑位，如果出现多个数抢同一个坑位，则找到重复的数。
即：如果当前数字是2，就将其与nums[2]位置的数交换，那么当前的数字就找到了正确的位置，如果交换的位置已经被2占了，说明是重复的。

时间复杂度$O(n)$, 空间复杂度$O(1)$

```c++
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        for(int i = 0; i < nums.size(); i++) { // 依次考虑nums[i]的正确位置
            while(nums[i] != i) { // 当前nums[i]的位置不对
                // 当前nums[i] = 2, 应该与nums[nums[i]] = nums[2]的元素交换
                if(nums[i] == nums[nums[i]]) return nums[i];
                else swap(nums[i], nums[nums[i]]);
            }
        }
        return -1;
    }   
};
```

