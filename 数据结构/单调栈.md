<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 单调栈 </font> </center>

适用场景：找出每个数左边**离它最近**的比它大/小的数
如果需要找右边的情况，倒着处理原数组

### 模板题：
输出数组中每个数左边**离它最近**的比它小的数，不存在-1
**stl**
```c++
stack<int>s;
for(auto x : a) {
    while (s.size() && x <= s.top()) s.pop();
    cout << (s.size() ? s.top() : -1) <<" ";
    s.push(x);
}
```
**数组模拟栈**
```c++
int stk[10010];
int tt = 0;
for(auto x : a) {
    while(tt > 0 && x <= stk[tt]) tt--;
    cout << (tt > 0 ? stk[tt] : -1) << " ";
    stk[++tt] = x;
}
```
---

### 739. 每日温度
题意：对于数组中的每个元素，找到它之后的比它大的第一个元素的**索引**
`a = [73,74,75,71,69,72,76,73], ans = [1,1,4,2,1,1,0,0]`

#### 思路1：倒序[常规单调栈做法]
遍历到`i`，就更新`ans[i]`
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& a) {
        vector<int>ans;
        stack<int>sk; //存放索引
        for (int i = a.size() - 1; i >= 0; i--) {
            while (sk.size() && a[i] >= a[sk.top()]) sk.pop();
            if(sk.empty()) ans.push_back(0);
            else ans.push_back(sk.top() - i);
            sk.push(i);
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

#### 思路2：正序
遍历到`i`，用`a[i]`确定`ans[j]` `j<i`
```c++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& a) {
        int n = a.size();
        vector<int>ans(n, 0); // 默认为0;
        stack<int>sk;
        for (int i = 0; i < n; i++) {
            // 判断当前元素a[i]是否比栈中的元素更大，如果大的话，说明a[i]就是第一个比它大的数
            while(sk.size() && a[i] > a[sk.top()]) {
                ans[sk.top()] = i - sk.top();
                sk.pop();
            }
            sk.push(i);
        }
        //最后仍在栈中的元素说明没有找到更大的，为0
        return ans;
    }
};
```
---

### 496. 下一个更大元素 I
题意：找到指定元素后面比它大的第一个元素的值，而非索引，不存在返回-1
`nums2`: 给定的数组，不含重复元素。`nums1`:`nums2`的子集
`nums1 = [4,1,2], nums2 = [1,3,4,2]. ans=[-1,3,-1]`

#### 思路：单调栈 + 哈希表
```c++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int>hx;
        int m = nums2.size();
        stack<int>sk; //存放元素值
        for (int i = m - 1; i >= 0; i--) {
            int x = nums2[i];
            while (sk.size() && x > sk.top()) sk.pop();
            if (sk.empty()) hx[x] = -1;
            else hx[x] = sk.top();
            sk.push(x);
        }
        vector<int>ans;
        for (auto x : nums1) ans.push_back(hx[x]);
        return ans;
    }
};
```
---

### 503. 下一个更大元素 II
题意：在数组中找到每个元素后面比它大的第一个元素，可以**循环**找
`nums = [1,2,3,4,3], ans= [2,3,4,-1,4]`

#### 思路1：将原数组变长为2倍
```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        nums.insert(nums.end(), nums.begin(), nums.end());
        int n = nums.size();
        vector<int>ans;
        stack<int>sk; //存值
        for (int i = n - 1; i >= 0; i--) {
            while (sk.size() && nums[i] >= sk.top()) sk.pop();
            if(sk.empty()) ans.push_back(-1);
            else ans.push_back(sk.top());
            sk.push(nums[i]);
        }
        reverse(ans.begin(), ans.end()); 
        return {ans.begin(), ans.begin() + n / 2};
        
    }
};
```

#### 思路2：用取余运算
```c++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
       stack<int>sk; //存放索引
       int n = nums.size();
       vector<int> ans(n, -1);
       for (int i = 0 ; i < 2 * n; i++) {
           while(sk.size() && nums[i % n] > nums[sk.top()]) {
               if(sk.top() < n) ans[sk.top()] = nums[i % n];
               sk.pop();
           } 
           sk.push(i % n);
       }
       return ans;
    }
};
```
---

### 42. 接雨水
题意：`height = [4,2,0,3,2,5],ans = 9`

#### 思路1：单调栈[易错]
1. 首先用栈维护一个单调下降的（即栈从下往上，不断降低）
2. 情况1：`[4, 2, 1, 6]` 当前考虑元素`6`, 依次考虑栈中的元素`[1, 2, 4]`可以存放的水量
3. 情况2：`[4, 2, 1, 3]`：处理完左边低的柱子，如果还有高的柱子，就处理当前柱子可以存放的水量
4. 每次用一个last记录上一次处理水的高度。

**时间复杂度：$O(n)$**
```c++
class Solution {
public:
    int trap(vector<int>& a) {
        stack<int>sk;//存索引，因为需要知道间隔多少
        int ans = 0;
        for(int i = 0; i < a.size(); i++) {
            int last = 0; // 记录上一次处理的高度
            while(sk.size() && a[i] >= a[sk.top()]) { // 处理比当前柱子低的
                int k = sk.top(); 
                sk.pop();
                ans += (a[k] - last) * (i - k - 1);
                last = a[k];
            }
            // 如果左边存在比当前柱子高的，再加上当前柱子可以存放的水
            if(sk.size()) ans += (a[i] - last) * (i - sk.top() - 1);
            sk.push(i);
        }
        return ans;
    }
};
```
**另一种实现思路：**
1. 用栈维护一个单调下降的（即栈从下往上，不断降低）
2. 如果当前元素大于栈首元素并且栈中有两个以上的元素,那么一定有水，开始计算存水量，每次比较最低的柱子，避免上面一样分类讨论

```c++
class Solution {
public:
    int trap(vector<int>& a) {
        stack<int>sk;//存索引，因为需要知道间隔多少
        int ans = 0;
        for(int i = 0; i < a.size(); i++) {
            while (sk.size() && a[i] > a[sk.top()]) { 
                int mid = sk.top();
                sk.pop();
                if(sk.empty()) break;
                int l = sk.top(), r = i;
                int h = min(a[l], a[r]) - a[mid];
                ans += h * (r - l - 1);
            }
            sk.push(i);
        }
        return ans;
    }
};
```

#### 思路2：`DP`[简单不容易错]
不同于上述思路是按行考虑能攒多少水，现在的想法是按列考虑，
对于每一列`i`,能攒的水就是左右两边柱子的最大值中较小的那个-a[i]
因此先用DP预处理出每个索引左边和右边柱子的最大值
然后直接遍历一遍原数组就可

**时间复杂度：$O(n)$**
```c++
class Solution {
public:
    int trap(vector<int>& a) {
        int n = a.size();
        vector<int>dpl(n), dpr(n);
        // dpl[i]：i的左边，包括i的最大值, dpr[i]:i的右边：包括i的最大值
        dpl[0] = a[0], dpr[n - 1] = a[n - 1];
        for (int i = 1; i < n; i++) dpl[i] = max(dpl[i - 1], a[i]);
        for (int i = n - 2; i >= 0; i--) dpr[i] = max(dpr[i + 1], a[i]);
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += min(dpl[i], dpr[i]) - a[i];
        }
        return ans;
    }
};
```

#### 思路3：双指针
本质就是对上述DP的空间优化，因为每次更新其实都仅仅依赖每个柱子左右两边柱子的最小值。
定义`l,r`两个指针，`l`向右，`r`向左
用`lmax`维护当前`l`指针走过的最大值，`rmax`维护当前`r`指针走过的最大值
- 当`a[l] < a[r]`: 肯定有`lmax < rmax`, 所以`l`柱子水量仅依赖于小值`lmax`
- 当`a[l] >= a[r]`: 肯定有`lmax >= rmax`, 所以`r`柱子水量仅依赖于小值`rmax`

```c++
class Solution {
public:
    int trap(vector<int>& a) {
        int l = 0, r = a.size() - 1;
        int lmax = 0, rmax = 0;
        int ans = 0;
        while(l <= r) {
            lmax = max(lmax, a[l]);
            rmax = max(rmax, a[r]);
            if (a[l] < a[r]) { // 计算l处的水量
                ans += lmax - a[l];
                l++;
            }
            else {  // 计算r处的水量
                ans += rmax - a[r];
                r--;
            }
        }
        return ans;
    }
};
```
---


### 84. 柱状图中最大的矩形
题意；给一行柱子的高度，找到其中面积最大的矩形
`heights = [2,1,5,6,2,3]， ans = 10`

#### 思路1：单调栈 [容易想到和实现]
对于每根柱子，将其作为要枚举的矩形的高度，然后找到每根柱子左边和右边第一个小于它的柱子(小于的话意味着当前矩形高度不能继续延伸),中间的柱子表示可以用当前高度来算矩形。如果直接这样做的话，时间复杂度是$O(n^2)$,但是可以用单调栈预处理出来每个柱子左边(右边)第一个小于它的柱子的索引。

**时间复杂度:$O(n)$**

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& a) {
        int n = a.size();
        stack<int>sk;
        vector<int>lmin; //lmin[i]表示i左边小于a[i]的索引
        for (int i = 0; i < n; i++) {
            while(sk.size() && a[i] <= a[sk.top()]) sk.pop();
            if (sk.size()) lmin.push_back(sk.top());
            else lmin.push_back(-1);
            sk.push(i);
        }
        while (sk.size()) sk.pop();
        vector<int>rmin(n);
        for (int i = n - 1; i >= 0; i--) {
            while(sk.size() && a[i] <= a[sk.top()]) sk.pop();
            if(sk.size()) rmin[i] = sk.top();
            else rmin[i] = n;
            sk.push(i);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int sum = a[i] * (rmin[i] - lmin[i] - 1);
            ans = max(ans, sum);
        }
        return ans;
    }
};
```
---