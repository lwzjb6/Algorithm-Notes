<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 栈 </font> </center>

### 数组模拟栈
```c++
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[++tt] = x;

// 从栈顶弹出一个数
tt--;

// 栈顶的值
stk[tt];

// 判断栈是否为空
tt > 0 ? "NO" : "YES"
```

### 232. 用栈实现队列
题意：使用两个栈实现队列的各种功能
```c++
class MyQueue {
private:
    stack<int>in, out;
public:
    MyQueue() {

    }
    
    void push(int x) {
        in.push(x);
    }
    
    int pop() {
        if(out.empty()) {
            while(in.size()) {
                out.push(in.top());
                in.pop();
            }
        }
        int e = out.top();
        out.pop();
        return e;
    }
    
    int peek() {
        if(out.empty()) {
            while(in.size()) {
                out.push(in.top());
                in.pop();
            }
        }
        return out.top();
    }
    
    bool empty() {
        if(in.empty() && out.empty()) return 1;
        return 0;
    }
};
```
---

### 20. 有效的括号
题意：给定一个仅含`(,[,{,),],}`6种字符的字符串，判断是否合法
`s = "()[]{}",  ans = 1`
#### 思路：栈
涉及到括号的匹配问题，通常借助栈
基本思路：
- 如果当前是左括号，直接入栈
- 如果当前是右括号，栈中没有元素或者栈首的括号与当前右括号不匹配，返回`False`,否则的话说明可以匹配，弹出栈首的元素。
```c++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char, int>hx = {
            {'(', 0} , {')', 1}, {'[', 2}, {']', 3}, {'{', 4}, {'}', 5}};
        stack<char>sk;
        for (auto c : s) {
            if (hx[c] % 2 == 0) sk.push(c); //左括号
            else { //右括号
                if(sk.empty() || hx[c] - 1 != hx[sk.top()]) return 0;
                else sk.pop();
            }
        }
        return sk.empty() ? 1 : 0;
    }
};
```
```c++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char, char>hx = {
            {')', '('}, 
            {']', '['}, 
            {'}', '{'}};
        stack<char>sk;
        for (auto c : s) {
            if (hx.count(c)) { // 右括号
                if (sk.empty() || hx[c] != sk.top()) return 0;
                else sk.pop();
            }
            else sk.push(c);
        }
        return sk.empty();
    }
};
```
---

### 150. 逆波兰表达式求值
题意：逆波兰表达式也叫后缀表达式（将运算符写在操作数之后）。
`["2","1","+","3","*"], ans = (4 + (13 / 5)) = 6`

```C++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long>sk;
        for (auto s : tokens) {
            if (s == "+" || s == "-" || s == "*" || s == "/") {
                int b = sk.top();
                sk.pop();
                int a = sk.top();
                sk.pop();
                if(s == "+") sk.push(a + b); 
                else if(s == "-") sk.push(a - b);
                else if(s == "*") sk.push((long long)a * b);
                else if(s == "/") sk.push(a / b); 
            }
            else sk.push(stoi(s));
        }
        return sk.top();
    }
};
```
---

### acwing 3302. 表达式求值
`(2+2)*(1+1), ans = 8`
**核心思路：**
(1) 双栈，一个操作数栈，一个运算符栈
(2) 即将入栈的运算符和栈顶的运算符进行比较：
如果 即将入栈的运算符 优先级较高，则直接入栈
否则，不断将栈顶的运算符和操作数栈中的两个数进行运算
注意这里不能用`if`计算一次，要用`while`不断计算
举例说明：`5 - 1 * 2 + 3` 
如果用`if`的话, 计算的情况是` 5 - ((1 * 2) + 3) = 0`
所以要用`while`满足运算符从左往右的运算顺序 
(3) 括号的问题：
左括号直接入栈，遇到右括号，一直运算操作数栈中的运算符,直到遇到左括号

```c++
# include<bits/stdc++.h>
using namespace std;
stack<int>nums;
stack<char>op;
// 定义优先级
unordered_map<char, int>hx = {{'(', 0}, {'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
void eval() {
    int a = nums.top();
    nums.pop();
    int b = nums.top();
    nums.pop();
    char c = op.top();
    op.pop();
    // 前面的数是b, 后面的数是a
    if (c == '+') nums.push(b + a);
    else if (c == '-') nums.push(b - a);
    else if (c == '*') nums.push(b * a);
    else if (c == '/') nums.push(b / a);
}
int main() {
    string s;
    cin >> s;
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        if (isdigit(c)) { // 读完整个数字
            int j = i;
            string e;
            while (j < s.size() && isdigit(s[j])) {
                e += s[j];
                j++;
            }
            nums.push(stoi(e));
            i = j - 1;
        }
        else if (c == '(') op.push(c);
        else if (c == ')') {
            while (op.top() != '(') {
                eval();
            }
            op.pop(); // 去掉左括号
        }
        else {
            // 即将入栈的运算符优先级小于等于栈顶元素
            // 这里用while，上面有解释
            while (op.size() && hx[c] <= hx[op.top()]) {
                eval();
            }
            op.push(c);
        }
    }
    while (op.size()) eval();
    cout << nums.top() << endl;
    return 0;
}
```
---
