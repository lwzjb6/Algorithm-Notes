<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 线段树 </font> </center>

适用问题：在序列上`(1)`单点修改，区间查询 `(2)`区间修改，单点查询 `(3)` 区间修改，区间查询的问题。前提是维护的信息容易按照区间进行划分和合并(即满足区间的可加性)。只需要在父子传递信息和更新答案时更新即可。

**时间复杂度$O(qlogn)$** `q`为操作次数。

**常用操作（5个）**
```c++
1. build(int u, int l, int r) // 当前所在节点为u, 维护的区间是[l, r]
2. modify(int u, int x, int v) // 把点x的值修改为v, 当前所在节点为u
3. query(int u, int l, int r) // 当前所在节点为u, 查询的区间是[l, r]
4. pushup() // 根据子节点的信息从下往上更新父节点的信息
5. pushdown() // 根据父节点的信息从上往下更新子节点的信息。（懒标记， 延迟标记）
```
---

#### 题型一： 单点修改，区间查询

### acwing 1275. 最大数[模板题]
给一个数列，两种操作：
（1）添加操作：向序列后添加一个数  `A t` 表示加入一个数（`(t + a) % p` ,`a`是上次询问的答案）
（2）询问操作：询问这个序列中最后`L`个数中最大的数是多少 `Q L`

```c++
10 100
A 97
Q 1
A 17
Q 2
A 63
Q 1

ans:
97
97
60
```

```c++
# include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
using ll = long long;

int m, p;

// 线段树节点
struct node{
    int l, r;
    int v; // 维护最大值
};
node tr[4 * N]; // 开4倍序列的大小

// 本题是先搭建好框架，树中并没有放具体的值，之后再放，因此不需要pushup操作
void build(int u, int l, int r) {
    tr[u] = {l, r}; // 没有具体的值，所以不需要修改v
    if(l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid);
    build(u << 1 | 1, mid + 1, r);
}

void pushup(int u) { // 根据u的子节点信息更新u节点
    tr[u].v = max(tr[u << 1].v, tr[u << 1 | 1].v);
}

// 不断插入元素的过程等同于把对应索引x的元素修改为v
// 从根往下找，找到后从下往上pushup
void modify(int u, int x, int v) {
    if(tr[u].l == tr[u].r) tr[u].v = v; // 叶子节点
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1, x, v); // 索引x在左子树
        else modify(u << 1 | 1, x, v); // 索引x在右子树
        pushup(u);
    }
}

int query(int u, int l, int r) {
    if(l <= tr[u].l && r >= tr[u].r) return tr[u].v; // 完全包含
    int mid = tr[u].l + tr[u].r >> 1;
    int val = 0;
    if(l <= mid) val = max(val, query(u << 1, l, r)); // 左节点与[l,r]有重叠部分，访问左节点
    if(r > mid) val = max(val, query(u << 1 | 1, l, r)); // 右节点与[l,r]有重叠部分，访问右节点
    return val;
}

int main() {
    cin >> m >> p;
    // 初始化建树
    build(1, 1, m); // 最坏情况下有m个节点, 每次都是add操作
    int n = 0, last = 0; // 节点个数和上一次的查询结果
    while(m --) {
        char op;
        int x;
        cin >> op >> x;
        if(op == 'A') { 
            modify(1, ++n, ((ll)x + last) % p);
        }
        else {
            last = query(1, n - x + 1, n);
            cout << last << endl;
        }
    }
    return 0;
}
```
---


### 1157. 子数组中占绝大多数的元素
给定一个数组，多次询问，`[l, r, threshold]` 问`[l, r]`中的众数的次数是否大于等于`threshold`, 如果大于等于，返回对应的众数，否则，返回`-1`

思路分析：
(1) 首先我们用哈希表`hx`记录每个数出现的所有位置。
(2) 假设我们知道待查询区间`[l, r]`的众数为`x`, 其出现的所有位置为`hx[x]`, 则可以直接用二分算法`lower_bound` 求出其出现的个数。然后和`threshold`比较看是否满足条件。

核心问题：如果快速找出区间`[l, r]`的众数呢？
**线段树 + 摩尔投票**
线段树维护当前区间的众数以及众数的出现次数。
核心操作`pushup:`
```c++
void pushup(int u) { // 用u的子节点更新节点u, 利用了摩尔投票法的思想
    auto lson = tr[u << 1], rson = tr[u << 1 | 1];
    if(lson.x == rson.x) {
        tr[u].x = lson.x;
        tr[u].cnt = lson.cnt + rson.cnt;
    } 
    else if(lson.cnt >= rson.cnt) {
        tr[u].x = lson.x;
        tr[u].cnt = lson.cnt - rson.cnt;
    }
    else { // lson.cnt < rson.cnt
        tr[u].x = rson.x;
        tr[u].cnt = rson.cnt - lson.cnt;
    }
}
```

#### 线段树 + 摩尔投票 + 二分查找

```c++
class MajorityChecker {
public:
    static const int N = 2e4 + 5;
    using pii = pair<int, int>;
    struct node{
        int l, r;
        int x, cnt; // 区间众数，以及出现的次数
    };
    node tr[4 * N];
    vector<int>nums; // 拷贝一份，便于build操作

    void build(int u, int l, int r) {
        tr[u] = {l, r};
        if(l == r) { // 叶子节点
            tr[u].x = nums[l - 1]; // 索引从0开始
            tr[u].cnt = 1;
            return;
        }
        int mid = (l + r) >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }

    void pushup(int u) { // 用u的子节点更新节点u, 利用了摩尔投票法的思想
        auto lson = tr[u << 1], rson = tr[u << 1 | 1];
        if(lson.x == rson.x) {
            tr[u].x = lson.x;
            tr[u].cnt = lson.cnt + rson.cnt;
        } 
        else if(lson.cnt >= rson.cnt) {
            tr[u].x = lson.x;
            tr[u].cnt = lson.cnt - rson.cnt;
        }
        else { // lson.cnt < rson.cnt
            tr[u].x = rson.x;
            tr[u].cnt = rson.cnt - lson.cnt;
        }
    }

    pii ask(int u, int l, int r) { // 返回众数以及出现的次数
        if(l <= tr[u].l && r >= tr[u].r)  return {tr[u].x, tr[u].cnt};
        int mid = (tr[u].l + tr[u].r) >> 1;
        if(r <= mid) return ask(u << 1, l, r); // 只可能在左子树 
        if(l > mid) return ask(u << 1 | 1, l, r); // 只可能在右子树
        auto [lx, lc] = ask(u << 1, l, r);
        auto [rx, rc] = ask(u << 1 | 1, l, r);
        pii ans;
        if(lx == rx) ans = {lx, lc + rc};
        else if(lc >= rc) ans = {lx, lc - rc};
        else ans = {rx, rc - lc};
        return ans;
    }

    unordered_map<int, vector<int>>hx; // 存每个数所在的索引的位置
    MajorityChecker(vector<int>& arr) {
        nums = arr; // 便于build线段树
        int n = nums.size();
        build(1, 1, n);
        for(int i = 0; i < arr.size(); i++) 
            hx[arr[i]].push_back(i);
    }
    
    int query(int left, int right, int threshold) {
        int x = ask(1, left + 1, right + 1).first; // 找到众数
        auto l = lower_bound(hx[x].begin(), hx[x].end(), left);
        auto r = lower_bound(hx[x].begin(), hx[x].end(), right + 1);
        return (r - l >= threshold) ? x : -1;
    }
};
```
---