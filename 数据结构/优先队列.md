<font face="楷体" size = 3>

<center><font face="楷体" size=6, color='red'> 优先队列 </font> </center>

#### 基础知识
```c++
priority_queue<int>pq; //从大到小
priority_queue<int, vector<int>, greater<int>>pq; //从小到大
```
自己写的结构体，自定义排序规则(常用)
注意：记的时候到底是大于还是小于，与平常思维相反就可。
- 方法1：重载'<'
  ```c++
  struct node {
    int x,y;
    friend bool operator < (node a, node b) { 
        return a.y > b.y;   // y越大优先级越小,适用于按y从小到大排序的
        return a.y < b.y;   // y越小优先级越小,适用于按y从大到小排序的
    }
  };

  //使用:
  pririty_queue<node>pq;
  ```
- 方法2：仿函数
  ```c++
  struct node {
    int x,y;
  };
  struct cmp {
    bool operator () (node a, node b){
        return a.y > b.y; // 按y从小到大排序
        return a.y < b.y; // 按y从大到小排序
    }
  }
  //使用:
  pririty_queue<node, vector<node>, cmp>pq;
  ```

### 模拟堆




---
### 347. 前`K`个高频元素
题意：找到数组中出现次数前k高的数字

#### 思路1：哈希 + 优先队列
统计每个数字的出现次数，然后放入优先队列中排序，最后挑出来前k大的
时间复杂度$O(nlogn)$
```c++
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int>hx;
        priority_queue<pair<int, int>>pq;
        vector<int>ans;
        for (auto x : nums) hx[x]++;
        for (auto [k, v] : hx) pq.push({v, k}); //反过来存
        while (k--) {
            ans.push_back(pq.top().second);
            pq.pop();
        }
        return ans;
    }
};
```
自定义排序规则：更为灵活
```c++
class Solution {
public:
    // 方法1：
    // struct node {
    //     int num;
    //     int cnt;
    //     friend bool operator < (node a, node b) {
    //         return a.cnt < b.cnt;
    //     }
    // };
    // 方法2：
    struct node {
        int num;
        int cnt;
    };
    struct cmp {
        bool operator () (node a, node b) {
            return a.cnt < b.cnt;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int>hx;
        //priority_queue<node>pq; // 方法1
        priority_queue<node, vector<node>, cmp>pq; // 方法2
        vector<int>ans;
        for (auto x : nums) hx[x]++;
        for (auto [k, v] : hx) pq.push({k, v});
        while (k--) {
            ans.push_back(pq.top().num);
            pq.pop();
        }
        return ans;
    }
};
```

#### 思路2：基于快速排序思想
时间复杂度：$O(n)$
```c++
class Solution {
public:
    struct node {
        int x,y;
    };
    vector<int>ans;
    void quick_sort(vector<node>& v, int l, int r, int k) {
        if (l == r) { // 当前还需要找，但是就一个元素不需要排序了
            ans.push_back(v[l].x);
            return;
        }
        int i = l - 1, j = r + 1, x = v[(l + r) >> 1].y;
        while(i < j) {
            while (v[++i].y < x);
            while (v[--j].y > x);
            if (i < j) swap(v[i], v[j]);
        }
        //到此[l,j]的元素的次数小于等于x,[j+1,r]的元素的次数大于等于x
        int sr = r - j; // 右区间的个数
        if (sr < k) { //已经找到sr个大的,还需要找k-sr个
            for (int p = j + 1; p <= r ; p++) ans.push_back(v[p].x);
            quick_sort(v, l, j, k - sr);
        } // 继续在右区间找k个大的
        else quick_sort(v, j + 1, r, k);
    }
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int>hx;
        for (auto x : nums) hx[x]++;
        vector<node>v;
        for (auto [x, y] : hx) v.push_back({x, y});
        // 对v进行快速选择，根据y值
        quick_sort(v, 0, v.size() - 1, k);
        return ans;
    }
};
```
---