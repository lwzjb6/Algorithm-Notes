<font face= "楷体" size = 3>
---
<center><font face="楷体" size=6, color='red'> 编辑距离问题 </font> </center>

### 72. 编辑距离
给你两个单词 `word1` 和 `word2`， 请返回将 `word1` 转换成`word2` 所使用的最少操作数  。
操作3种：插入、删除、替换
`word1 = "horse", word2 = "ros", ans = 3`

**状态表示**：`f[i][j]`:`word1`的前`i`个字符转化为`word2`的前`j`个字符的编辑距离
**状态转移**：
```c++
<1> word1[i - 1] != word2[j - 1]: （索引从0开始）
(1) f[i][j] = f[i - 1][j - 1] + 1 (当前位置的替换操作)
(2) f[i][j] = f[i - 1][j] + 1 (当前位置删除操作)
(3) f[i][j] = f[i][j - 1] + 1 (当前位置后面添加word2[j - 1])

<2> word1[i - 1] == word2[j - 1]:
(1) f[i][j] = f[i -1][j - 1]
(2) f[i][j] = f[i - 1][j] + 1 (当前位置删除操作)
(3) f[i][j] = f[i][j - 1] + 1 (当前位置后面添加word2[j - 1])
```
```c++
class Solution {
public:
    int minDistance(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1, 0));
        for (int i = 0; i <= n; i++) f[i][0] = i;
        for (int j = 0; j <= m; j++) f[0][j] = j;
        for (int i = 1; i <= n; i++) 
            for (int j = 1; j <= m; j++) {
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; // 删除 or 插入
                if (w1[i - 1] == w2[j - 1]) f[i][j] = min(f[i - 1][j - 1], f[i][j]);
                else  f[i][j] = min(f[i - 1][j - 1] + 1, f[i][j]);
            }
        return f[n][m];
    }
};
```
---

### 剑指 Offer 19. 正则表达式匹配

模式串`p`中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含`0`次）。问字符串`s`与模式串`p`是否匹配
`s= "aaa", p = "ab*ac*a", ans = True`
`s = "aab", p = "c*a*." ans = true`

#### DP

状态表示；`f[i][j]`: `s`前`i`个字符是否与`p`前`j`个字符匹配

状态转移：**[难点]**

<img src="../Fig/正则表达式匹配.png" width=60%>

```c++
bool match(int i, int j) {
    if (s[i] == p[j] || p[j] == '.') return 1;
    return 0;
}

(1) p[j] != '*'
f[i][j] = f[i - 1][j - 1] && match(i , j);

(2) p[j] == '*'
// 分别匹配0个，1个，2个。。。只要有一种可以就能匹配
f[i][j] = f[i][j - 2] || f[i - 1][j - 2] && match(i, j - 1) || f[i - 2][j - 2] && match(i ,j - 1) && match(i - 1, j - 1) && ....

对上述式子变形：
f[i - 1][j] =            f[i - 1][j - 2] || f[i - 2][j - 2] && match(i - 1,j - 1) || ....

找上述两式的关系：
f[i][j] = f[i][j - 2] || (f[i - 1][j] && macth(i, j - 1)) [最终的状态转移方程]

```

```c++
class Solution {
public:

    bool isMatch(string s, string p) {
        int n = s.size(), m = p.size();
        s = ' ' + s, p = ' ' + p; // 为了从1开始处理
        vector<vector<int>>f(n + 1, vector<int>(m + 1, 0));

        auto match = [=](int i, int j){
            if(s[i] == p[j]) return 1;
            if(p[j] == '.') return 1;
            return 0;
        };

        f[0][0] = 1;
        for(int i = 0; i <= n; i++) { // 这边从0开始看，因为s="",p=".*" 也可以是对的
            for(int j = 1; j <= m; j++) {
                if(p[j] != '*') f[i][j] = i && f[i - 1][j - 1] && match(i, j);
                else {
                    f[i][j] = (j >= 2) && f[i][j - 2] || (i && f[i - 1][j] && match(i, j - 1));
                }
            }
        }
        return f[n][m];
    }
};
```
---


### 1653. 使字符串平衡的最少删除次数
将给定的字符串变成`a`全在`b`左边的最小删除次数

#### 前后缀分解
枚举所有分割线的位置，左边为`a`的区域，右边为`b`的区域
因此左区域中的`b`和右区域中的`a`为要删除的元素。

如何快速统计呢？
`del`起始为`a`的总数，代表分割线为0之前的最少删除次数
每个分割线往后移动，如果遇到`a`，相当于一个非法的`a`从右区间移动到了左区间，删除次数减`1`, 如果遇到`b`；相当于一个合法的`b`从右区间来到了左区间，删除次数加`1`

```c++
class Solution {
public:
    int minimumDeletions(string s) {
        int n = s.size();
        int del = 0; // 统计a的个数，作为初始值
        for(auto c : s) if (c == 'a') del++;
        int ans = del;
        for(int i = 0; i < n; i++) { // i表示左区间的结尾
            if(s[i] == 'a') del--;
            else del++;
            ans = min(ans, del);
        }
        return ans;
    }
};
```

#### DP
状态表示：`f[i]:`仅考虑前`i`个字符的最少删除次数
状态转移：
`(1) s[i] == 'b': f[i] = f[i - 1] `(直接加到后面就行)
`(2) s[i] == 'a:`
`<1> f[i] = f[i - 1] + 1` (不选当前字符，即为删除次数加1)
`<2> f[i] = cntb ` (选当前字符，删除的次数为前面b的次数)

```c++
class Solution {
public:
    int minimumDeletions(string s) {
        int n = s.size();
        int cntb = 0;
        int f = 0; // f[i]压缩到一维
        for(int i = 0; i < n; i++) {
            if(s[i] == 'b') cntb++; // f不变
            else f = min(f + 1, cntb);
        }
        return f;
    }
};
```