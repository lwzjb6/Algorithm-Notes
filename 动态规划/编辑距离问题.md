<font face= "楷体" size = 3>
---
<center><font face="楷体" size=6, color='red'> 编辑距离问题 </font> </center>

### 72. 编辑距离
给你两个单词 `word1` 和 `word2`， 请返回将 `word1` 转换成`word2` 所使用的最少操作数  。
`word1 = "horse", word2 = "ros", ans = 3`

**状态表示**：`f[i][j]`:`word1`的前`i`个字符转化为`word2`的前`j`个字符的编辑距离
**状态转移**：
```c++
<1> word1[i - 1] != word2[j - 1]: （索引从0开始）
(1) f[i][j] = f[i - 1][j - 1] + 1 (当前位置的替换操作)
(2) f[i][j] = f[i - 1][j] + 1 (当前位置删除操作)
(3) f[i][j] = f[i][j - 1] + 1 (当前位置后面添加word2[j - 1])

<2> word1[i - 1] == word2[j - 1]:
(1) f[i][j] = f[i -1][j - 1]
(2) f[i][j] = f[i - 1][j] + 1 (当前位置删除操作)
(3) f[i][j] = f[i][j - 1] + 1 (当前位置后面添加word2[j - 1])
```
```c++
class Solution {
public:
    int minDistance(string w1, string w2) {
        int n = w1.size(), m = w2.size();
        vector<vector<int>>f(n + 1, vector<int>(m + 1, 0));
        for (int i = 0; i <= n; i++) f[i][0] = i;
        for (int j = 0; j <= m; j++) f[0][j] = j;
        for (int i = 1; i <= n; i++) 
            for (int j = 1; j <= m; j++) {
                f[i][j] = min(f[i - 1][j], f[i][j - 1]) + 1; // 删除 or 插入
                if (w1[i - 1] == w2[j - 1]) f[i][j] = min(f[i - 1][j - 1], f[i][j]);
                else  f[i][j] = min(f[i - 1][j - 1] + 1, f[i][j]);
            }
        return f[n][m];
    }
};
```
---